generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                      String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  email                   String            @unique @db.VarChar(255)
  username                String            @unique @db.VarChar(50)
  password_hash           String            @default("") @db.VarChar(255)
  avatar_url              String?
  bio                     String?
  xp                      Int               @default(0)
  level                   Int               @default(1)
  streak_days             Int               @default(0)
  last_read_at            DateTime?         @db.Timestamptz(6)
  default_source          String?           @db.VarChar(50)
  notification_settings   Json              @default("{\"push\": false, \"email\": true}")
  privacy_settings        Json              @default("{\"library_public\": true, \"activity_public\": true}")
  safe_browsing_mode      String            @default("sfw") @db.VarChar(20)
  safe_browsing_indicator String            @default("toggle") @db.VarChar(20)
  subscription_tier       String            @default("free") @db.VarChar(20)
  subscription_expires_at DateTime?         @db.Timestamptz(6)
  created_at              DateTime          @default(now()) @db.Timestamptz(6)
  updated_at              DateTime          @default(now()) @updatedAt @db.Timestamptz(6)
  chapters_read           Int               @default(0)
  longest_streak          Int               @default(0)
  activities              Activity[]
  followers               Follow[]          @relation("follower")
  following               Follow[]          @relation("following")
  import_jobs             ImportJob[]
  library_entries         LibraryEntry[]
  triggered_notifications Notification[]    @relation("actor")
  notifications           Notification[]
  achievements            UserAchievement[]

  @@index([username])
  @@index([xp(sort: Desc)])
  @@map("users")
}

model Series {
  id                 String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  mangadex_id        String?        @unique @db.VarChar(255)
  title              String         @db.VarChar(500)
  alternative_titles Json           @default("[]")
  description        String?
  cover_url          String?
  type               String         @db.VarChar(20)
  status             String?        @db.VarChar(20)
  genres             String[]       @db.VarChar(50)
  content_rating     String?        @db.VarChar(20)
  total_follows      Int            @default(0)
  total_views        Int            @default(0)
  average_rating     Decimal?       @db.Decimal(3, 2)
  tags               String[]       @db.VarChar(50)
  created_at         DateTime       @default(now()) @db.Timestamptz(6)
  updated_at         DateTime       @default(now()) @updatedAt @db.Timestamptz(6)
  activities         Activity[]
  chapters           Chapter[]
  library_entries    LibraryEntry[]
    notifications      Notification[]
    sources            SeriesSource[]

    @@index([title])
    @@index([status])
    @@index([type])
    @@index([total_follows(sort: Desc)])
    @@map("series")
  }

model SeriesSource {
  id                   String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  series_id            String    @db.Uuid
  source_name          String    @db.VarChar(50)
  source_id            String    @db.VarChar(255)
  source_url           String
  source_title         String?   @db.VarChar(500)
  source_chapter_count Int?
  trust_score          Decimal   @default(5.0) @db.Decimal(3, 2)
  last_checked_at      DateTime? @db.Timestamptz(6)
  last_success_at      DateTime? @db.Timestamptz(6)
  failure_count        Int       @default(0)
  match_confidence     Int?
  sync_priority        String    @default("COLD") @db.VarChar(10)
  next_check_at        DateTime? @default(now()) @db.Timestamptz(6)
  cover_url            String?
  cover_width          Int?
  cover_height         Int?
  cover_updated_at     DateTime? @db.Timestamptz(6)
  is_primary_cover     Boolean   @default(false)
  created_at           DateTime  @default(now()) @db.Timestamptz(6)
  chapters             Chapter[]
  series               Series    @relation(fields: [series_id], references: [id], onDelete: Cascade)

  @@unique([source_name, source_id])
  @@index([series_id])
  @@index([sync_priority, next_check_at])
  @@map("series_sources")
}

model Chapter {
  id               String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  series_id        String         @db.Uuid
  series_source_id String         @db.Uuid
  chapter_number   Decimal        @db.Decimal(10, 2)
  chapter_title    String?        @db.VarChar(500)
  volume_number    Int?
  chapter_url      String
  is_available     Boolean        @default(true)
  page_count       Int?
  published_at     DateTime?      @db.Timestamptz(6)
  discovered_at    DateTime       @default(now()) @db.Timestamptz(6)
  activities       Activity[]
  series           Series         @relation(fields: [series_id], references: [id], onDelete: Cascade)
  source           SeriesSource   @relation(fields: [series_source_id], references: [id], onDelete: Cascade)
  notifications    Notification[]

  @@unique([series_source_id, chapter_number])
  @@index([series_id, chapter_number(sort: Desc)])
  @@index([series_source_id, chapter_number(sort: Desc)])
  @@index([series_id, published_at(sort: Desc)])
  @@index([published_at(sort: Desc)])
  @@map("chapters")
}

model LibraryEntry {
  id                  String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id             String    @db.Uuid
  series_id           String    @db.Uuid
  status              String    @default("reading") @db.VarChar(20)
  last_read_chapter   Decimal?  @db.Decimal(10, 2)
  last_read_at        DateTime? @db.Timestamptz(6)
  user_rating         Int?
  preferred_source    String?   @db.VarChar(50)
  notify_new_chapters Boolean   @default(true)
  sync_priority       String    @default("WARM") @db.VarChar(10)
  added_at            DateTime  @default(now()) @db.Timestamptz(6)
  updated_at          DateTime  @default(now()) @updatedAt @db.Timestamptz(6)
  series              Series    @relation(fields: [series_id], references: [id], onDelete: Cascade)
  user                User      @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([user_id, series_id])
  @@index([user_id, status, updated_at(sort: Desc)])
  @@index([series_id, status])
  @@index([sync_priority, updated_at])
  @@map("library_entries")
}

model Notification {
  id            String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id       String    @db.Uuid
  type          String    @db.VarChar(50)
  title         String    @db.VarChar(255)
  message       String?
  series_id     String?   @db.Uuid
  chapter_id    String?   @db.Uuid
  actor_user_id String?   @db.Uuid
  metadata      Json?
  read_at       DateTime? @db.Timestamptz(6)
  created_at    DateTime  @default(now()) @db.Timestamptz(6)
  actor         User?     @relation("actor", fields: [actor_user_id], references: [id])
  chapter       Chapter?  @relation(fields: [chapter_id], references: [id], onDelete: Cascade)
  series        Series?   @relation(fields: [series_id], references: [id], onDelete: Cascade)
  user          User      @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id, created_at(sort: Desc)])
  @@index([user_id, read_at, created_at(sort: Desc)])
  @@map("notifications")
}

model Achievement {
  id                String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  code              String            @unique @db.VarChar(50)
  name              String            @db.VarChar(100)
  description       String?
  icon_url          String?
  xp_reward         Int
  rarity            String            @default("common") @db.VarChar(20)
  criteria          Json
  created_at        DateTime          @default(now()) @db.Timestamptz(6)
  user_achievements UserAchievement[]

  @@map("achievements")
}

model UserAchievement {
  id             String      @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id        String      @db.Uuid
  achievement_id String      @db.Uuid
  unlocked_at    DateTime    @default(now()) @db.Timestamptz(6)
  achievement    Achievement @relation(fields: [achievement_id], references: [id], onDelete: Cascade)
  user           User        @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([user_id, achievement_id])
  @@index([user_id, unlocked_at(sort: Desc)])
  @@map("user_achievements")
}

model Follow {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  follower_id  String   @db.Uuid
  following_id String   @db.Uuid
  created_at   DateTime @default(now()) @db.Timestamptz(6)
  follower     User     @relation("follower", fields: [follower_id], references: [id], onDelete: Cascade)
  following    User     @relation("following", fields: [following_id], references: [id], onDelete: Cascade)

  @@unique([follower_id, following_id])
  @@index([follower_id])
  @@index([following_id])
  @@map("follows")
}

model Activity {
  id             String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id        String   @db.Uuid
  type           String   @db.VarChar(50)
  series_id      String?  @db.Uuid
  chapter_id     String?  @db.Uuid
  achievement_id String?  @db.Uuid
  metadata       Json?
  created_at     DateTime @default(now()) @db.Timestamptz(6)
  chapter        Chapter? @relation(fields: [chapter_id], references: [id], onDelete: Cascade)
  series         Series?  @relation(fields: [series_id], references: [id], onDelete: Cascade)
  user           User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id, created_at(sort: Desc)])
  @@index([created_at(sort: Desc)])
  @@map("activities")
}

model ImportJob {
  id              String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id         String    @db.Uuid
  source          String    @db.VarChar(50)
  status          String    @default("pending") @db.VarChar(20)
  total_items     Int?
  processed_items Int       @default(0)
  matched_items   Int       @default(0)
  failed_items    Int       @default(0)
  error_log       Json?
  created_at      DateTime  @default(now()) @db.Timestamptz(6)
  completed_at    DateTime? @db.Timestamptz(6)
  user            User      @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id, created_at(sort: Desc)])
  @@map("import_jobs")
}
